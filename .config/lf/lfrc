# unmap stuff
map ,
map <c-d>
map <c-n>
map <backspace>
map d

# resize the lf pane to be a sidecar
${{
  current_window=$(tmux display-message -p '#I')
  pane_index=$(tmux display-message -p '#{pane_index}')
  pane_count=$(tmux list-panes -t $current_window -F '#{pane_index}' | wc -l)
  window_column_count=$(tmux display-message -p '#{window_width}')

  # if there are not multiple panes then we do not want to resize lf
  if [ "$pane_count" -eq 1 ]; then
    return 0
  fi

  if [ "$pane_index" -eq 0 ]; then
    resize_width=$(($window_column_count/5))
    tmux resize-pane -t 0 -x $resize_width
  fi
}}

# set preview to false by default
set preview false

# automatically quit the when there are no clients left
set autoquit true

# set preview to false by default
set preview false

# set hidden to true (show hidden)
set hidden true

# use bash for commands
set shell zsh

# set '-eu' options for shell commands
# These options are used to have safer shell commands. Option '-e' is used to
# exit on error and option '-u' is used to give error for unset variables.
# Option '-f' disables pathname expansion which can be useful when $f, $fs, and
# $fx variables contain names with '*' or '?' characters. However, this option
# is used selectively within individual commands as it can be limiting at
# times.
set shellopts '-eu'

# draw lines around the folders like in ranger
set drawbox true

# two column layout
set ratios 1:2

# draw vim like relative numbers
set relativenumber

# Use the `dim` attribute instead of underline for the cursor in the preview pane
set cursorpreviewfmt "\033[7;2m"
cmd open ${{
    case $(file --mime-type "$f" -bL) in
        text/*|application/json) $EDITOR "$fx";;
        *) for f in "$fx"; do xdg-open "$f"> /dev/null 2> /dev/null & done;;
    esac
}}

cmd fzf_search ${{
    RG_PREFIX="rg --column --line-number --no-heading --color=always --smart-case "
    res="$(
        FZF_DEFAULT_COMMAND="$RG_PREFIX ''" \
            fzf --bind "change:reload:$RG_PREFIX {q} || true" \
            --ansi --layout=reverse --header 'Search in files' \
            | cut -d':' -f1 | sed 's/\\/\\\\/g;s/"/\\"/g'
    )"
    [ -n "$res" ] && lf -remote "send $id select \"$res\""
}}

cmd git_branch ${{
    git branch | fzf | xargs git checkout
    pwd_shell=$(pwd | sed 's/\\/\\\\/g;s/"/\\"/g')
    lf -remote "send $id updir"
    lf -remote "send $id cd \"$pwd_shell\""
}}

cmd cd_and_quit &{{
  export LAST_LF_DIR="$PWD"
  # lf -remote "send :quit"
}}

cmd ripdrag-wrapper ${{ripdrag-wrapper $fx}}

cmd find_directory ${{
  if [ "$lf_hidden" ]; then
    lf -remote "send $id cd '$(fdfind --type d --exclude .git --exclude git --exclude .cargo --exclude node_modules --hidden | fzf)'"
    else 
    lf -remote "send $id cd '$(fdfind --type d --exclude .git --exclude git --exclude .cargo --exclude node_modules | fzf)'"
  fi
}}

cmd find_file ${{
  lf -remote "send $id select '$(fdfind --type f --exclude .git --exclude git --exclude .cargo --exclude node_modules --hidden | fzf)'"
}}

cmd split_to_nvim ${{
  if [ ! -f "$HOME/.tmux-pane-id" ]; then
    return 0
   fi
   # get the current window
   current_window=$(tmux display-message -p '#I')
  # get the last pane index
  last_pane=$(tail -n 2 ~/.tmux-pane-id | head -n 1)
  # check that we are not sending the open command to a neovim or lf pane
  pane_pid=$(tmux list-panes -t $current_window -F '#{pane_index} #{pane_pid}' | grep "$last_pane " | cut -d ' ' -f2 | head -n 1 )
  # try not to open the window in lf
  if $(pstree -p "$pane_pid" | grep -qE 'lf\([0-9]+\)'); then
    echo "refusing to open in lf"
    return 0
  fi
  # open the file path in a vim split
  if $(pstree -p "$pane_pid" | grep -qE 'nvim\([0-9]+\)'); then
    echo "opening $fx in a new pane"
    tmux send-keys -t "$last_pane" ":vsp $fx" Enter
    tmux select-pane -t "$last_pane"
    return 0
  fi
  # open the file in a new instance of vim
  git_root=$(git -C "$(dirname "$fx")" rev-parse --show-toplevel 2>/dev/null)
  echo $git_root
  if [ -n "$git_root" ]; then
    # inside a git repository, we should change the root directory
    tmux send-keys -t "$last_pane" "cd $git_root" C-m
    tmux send-keys -t "$last_pane" "nvim $fx" C-m
    tmux select-pane -t "$last_pane"
  else
      # not within a git repository
    tmux send-keys -t "$last_pane" "nvim $fx" C-m
    tmux select-pane -t "$last_pane"
  fi
}}

cmd cd_sync ${{
  if [ ! -f "$HOME/.tmux-pane-id" ]; then
    echo "no tmux pane history"
    return 0
  fi
  # get the current window
  current_window=$(tmux display-message -p '#I')
  # get the last pane index
  last_pane=$(tail -n 2 ~/.tmux-pane-id | head -n 1)
  if [ -z "$last_pane" ]; then
    echo "last_pane not found"
    return 0
  fi
  pane_pid=$(tmux list-panes -t $current_window -F '#{pane_index} #{pane_pid}' | grep "$last_pane " | cut -d ' ' -f2 )
  if [ -z "$pane_pid" ]; then
    echo "pane_pid not found"
    return 0
  fi
  # check we are not running anything in this pane
  if $(pstree -p "$pane_pid" | grep -qE '^zsh\([0-9]+\)$'); then
    tmux send-keys -t "$last_pane" "cd $PWD" C-m
    return 0
  fi
  echo "refusing to open in $last_pane"
}}

cmd new_file ${{
  # read user input
  clear
  echo "Please enter a file name:"
  read filename

  # check we are not overwriting anything
  if [ -f "$filename" -o -d "$filename" ]; then
    echo "refusing to overwrite $(basename $filename)"
    return 0
  fi

  # Remove leading /
  if [[ "$filename" == /* ]]; then
      filename="${filename:1}"
  fi

  # check if the last char is a /
  # this determines if we are creating a file or a folder
  last_character="${filename: -1}"
  if [ "$last_character" = "/" ]; then
    # create a folder
    mkdir -p $filename
  else
    # create a file
    mkdir -p $(dirname $filename)
    touch $filename
  fi
}}

# vim quit
cmd q :quit
# open a file
map <enter> open
# run a shell command
map <c-s> :shell
# toggle hidden files
map <backspace> set hidden!
# toggle preview
map ,p set preview!
# fuzzy file search for file and directory names
map <c-p> :find_file
map <c-d> :find_directory
map <c-c> ${{pwd | tr -d '\n' | wl-copy}}
# activate ripgrep search of text within files
map ,g :fzf_search
# copy my quit key bind in vim
map ,q :quit
# ripdrag
map ,d ripdrag-wrapper
# folder shortcuts
map gh ${{  lf -remote "send $id cd /home/$USERNAME"}}
map gd ${{  lf -remote "send $id cd /home/$USERNAME/dotfiles"; lf -remote "send $id set hidden true"}}
map ,1 set ratios 1
map ,2 set ratios 1:2
map <c-s> :cd_sync
map <c-o> :split_to_nvim
map <c-n> :new_file
map oo ${{sway-open --id $id $f}}
map op ${{sway-open --prompt $f}}

# show the result of execution of previous commands
map ` !true

# git keys
map gb :git_branch
map gp ${{clear; git pull --rebase || true; echo "press ENTER"; read ENTER}}
map gs ${{clear; git status; echo "press ENTER"; read ENTER}}
